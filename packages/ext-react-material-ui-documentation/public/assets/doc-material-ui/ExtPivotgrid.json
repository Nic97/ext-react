{
 "name": "Ext.pivot.Grid",
 "xtype": "pivotgrid",
 "reactname": "ExtPivotgrid",
 "alias": "widget.pivotgrid",
 "extended": "Ext.grid.Grid,Ext.dataview.List,Ext.dataview.Component,Ext.dataview.Abstract,Ext.Container,Ext.Component,Ext.Widget,Ext.Evented,Ext.Base",
 "extends": "Ext.grid.Grid",
 "mixed": "Ext.Mixin,Ext.mixin.Accessible,Ext.mixin.Bindable,Ext.mixin.Bufferable,Ext.mixin.ComponentDelegation,Ext.mixin.ConfigProxy,Ext.mixin.Container,Ext.mixin.Factoryable,Ext.mixin.Focusable,Ext.mixin.FocusableContainer,Ext.mixin.Identifiable,Ext.mixin.Inheritable,Ext.mixin.ItemRippler,Ext.mixin.Keyboard,Ext.mixin.Observable,Ext.mixin.Pluggable,Ext.mixin.Queryable,Ext.state.Stateful",
 "requires": "Ext.LoadMask,Ext.pivot.Row,Ext.pivot.feature.PivotStore,Ext.pivot.matrix.Local,Ext.pivot.matrix.Remote,Ext.data.ArrayStore",
 "text": "The pivot grid helps you analyze your data.\n\nCalculations can be done either in your browser using a {@link Ext.pivot.matrix.Local}\nmatrix or remotely on the server using a {@link Ext.pivot.matrix.Remote} matrix.\n\nExample usage:\n\n     {\n         xtype:  'pivotgrid',\n         matrix: {\n             type: 'local',\n             store: 'yourStoreId',    // or a store instance\n             rowGrandTotalsPosition: 'first',\n             leftAxis: [{\n                 dataIndex: 'country',\n                 direction: 'DESC',\n                 header: 'Countries',\n                 width: 150\n             }],\n             topAxis: [{\n                 dataIndex: 'year',\n                 direction: 'ASC'\n             }],\n             aggregate: [{\n                 dataIndex: 'value',\n                 header: 'Total',\n                 aggregator: 'sum',\n                 width: 120\n             }]\n         }\n     }\n\n\nThe modern pivot grid could be styled using data binding as following:\n\n## ViewModel on rows\n\nLet's have a look at this example:\n\n     {\n         xtype: 'pivotgrid',\n         itemConfig: {\n             viewModel: {\n                 type: 'pivot-row-model'\n             },\n             bind: {\n                 userCls: '{rowStyle}'\n                 // or you can define a template\n                 //userCls: '{record.isRowGroupHeader:pick(\"\",\"pivotRowHeader\")}'\n             }\n         }\n         // ... more configs\n     }\n\nIn the ViewModel we would declare a formula that will use the record data. The record\nhas all values that are displayed for that row and the following additional fields:\n\n- isRowGroupHeader\n- isRowGroupTotal\n- isRowGrandTotal\n- leftAxisKey: This is either the grand total key or a key that identifies the left axis item\n\nAll these properties can help us style the entire row without knowing anything about\nthe generated columns.\n\nIn some case we may want to style positive and negative values generated in the pivot grid.\nThis can be done as following.\n\n     {\n         xtype: 'pivotgrid',\n         itemConfig: {\n             viewModel: {\n                 type: 'default'\n             }\n         },\n         topAxisCellConfig: {\n             bind: {\n                 userCls: '{value:sign(\"pivotCellNegative\",\"pivotCellPositive\")}'\n             }\n         }\n         // ... more configs\n     }\n\nThe following data is available for use in the bind template:\n\n- column\n     - isColGroupTotal: this tells us that the column for that specific cell is a group total\n     - isColGrandTotal: this tells us that the column for that specific cell is a grand total\n\n- value: cell value\n\n**Note:** In such cases you cannot use formulas because the column and value are generated\ndynamically and can't be replaced in formulas.\n\n\nIt is also possible to style a specific dimension from left axis or aggregate:\n\n     {\n         xtype: 'pivotgrid',\n         itemConfig: {\n             viewModel: {\n                 type: 'default'\n             }\n         },\n         matrix: {\n             aggregate: [{\n                 dataIndex:  'value',\n                 aggregator: 'sum',\n                 align:      'right',\n\n                 cellConfig: {\n                     bind: {\n                         userCls: '{value:sign(\"pivotCellNegative\",\"pivotCellPositive\")}'\n                     }\n                 }\n             },{\n                 dataIndex:  'value',\n                 aggregator: 'count'\n             }],\n             leftAxis: [{\n                 dataIndex:  'person',\n                 // This is used only when `viewLayoutType` is `outline`\n                 cellConfig: {\n                     bind: {\n                         userCls: '{record.isRowGroupHeader::pick(\"\",\"pivotRowHeader\")}'\n                     }\n                 }\n             },{\n                 dataIndex:  'country'\n             }]\n             // ... more configs\n         }\n     }\n\n\n## ViewModel on cells\n\nThis scenario allows you to define formulas to use in cell binding. Be careful that this means\nthat each cell will have an own ViewModel and this may decrease the pivot grid performance.\nUse it only if necessary.\n\n     {\n         xtype: 'pivotgrid',\n         leftAxisCellConfig: {\n             viewModel: {\n                 type: 'default'\n             },\n             bind: {\n                 userCls: '{record.isRowGroupHeader::pick(\"\",\"pivotRowHeader\")}'\n             }\n         },\n         topAxisCellConfig: {\n             viewModel: {\n                 type: 'pivot-cell-model' // to be able to define your own formulas\n             },\n             bind: {\n                 userCls: '{value:sign(\"pivotCellNegative\",\"pivotCellPositive\")}'\n                 //userCls: '{column.isColGrandTotal:pick(null,\"pivotCellGrandTotal\")}'\n                 //userCls: '{cellCls}\n             }\n         }\n         // ... more configs\n     }\n\nThis approach lets you use record, column and value in both bind templates and formulas.\n\n\nIf multiple aggregate dimensions are available and you want to style one of them you can define\nthe binding on that dimension like this:\n\n     {\n         xtype: 'pivotgrid',\n         matrix: {\n             aggregate: [{\n                 dataIndex:  'value',\n                 aggregator: 'sum',\n                 align:      'right',\n\n                 cellConfig: {\n                     viewModel: {\n                         type: 'pivot-cell-model'\n                     },\n                     bind: {\n                         userCls: '{value:sign(\"pivotCellNegative\",\"pivotCellPositive\")}'\n                         //userCls: '{column.isColGrandTotal:pick(null,\"pivotCellGrandTotal\")}'\n                         //userCls: '{cellCls}\n                     }\n                 }\n             },{\n                 dataIndex:  'value',\n                 aggregator: 'count'\n             }]\n             // ... more configs\n         }\n     }\n"
}