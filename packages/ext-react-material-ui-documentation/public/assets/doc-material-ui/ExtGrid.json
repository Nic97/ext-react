{
 "name": "Ext.grid.Grid",
 "xtype": "grid",
 "reactname": "ExtGrid",
 "alias": "widget.grid",
 "extended": "Ext.dataview.List,Ext.dataview.Component,Ext.dataview.Abstract,Ext.Container,Ext.Component,Ext.Widget,Ext.Evented,Ext.Base",
 "extenders": "Ext.grid.Tree,Ext.pivot.Grid",
 "extends": "Ext.dataview.List",
 "mixed": "Ext.Mixin,Ext.mixin.Accessible,Ext.mixin.Bindable,Ext.mixin.Bufferable,Ext.mixin.ComponentDelegation,Ext.mixin.ConfigProxy,Ext.mixin.Container,Ext.mixin.Factoryable,Ext.mixin.Focusable,Ext.mixin.FocusableContainer,Ext.mixin.Identifiable,Ext.mixin.Inheritable,Ext.mixin.ItemRippler,Ext.mixin.Keyboard,Ext.mixin.Observable,Ext.mixin.Pluggable,Ext.mixin.Queryable,Ext.state.Stateful",
 "mixins": "Ext.mixin.ConfigProxy",
 "requires": "Ext.TitleBar,Ext.grid.NavigationModel,Ext.grid.Row,Ext.grid.column.Column,Ext.grid.column.Date,Ext.grid.column.Template,Ext.grid.menu.*,Ext.grid.HeaderContainer,Ext.grid.selection.*,Ext.grid.plugin.ColumnResizing,Ext.grid.plugin.HeaderReorder",
 "text": "Grids are an excellent way of showing large amounts of tabular data on the client side.\nEssentially a supercharged `<table>`, Grid makes it easy to fetch, sort and filter large\namounts of data.\n\nGrids are composed of two main pieces - a {@link Ext.data.Store} full of data and\na set of columns to render.\n\n## A Basic Grid\n\n    var store = Ext.create('Ext.data.Store', {\n        fields: ['name', 'email', 'phone'],\n        data: [\n            { 'name': 'Lisa',  \"email\":\"lisa@simpsons.com\",  \"phone\":\"555-111-1224\"  },\n            { 'name': 'Bart',  \"email\":\"bart@simpsons.com\",  \"phone\":\"555-222-1234\" },\n            { 'name': 'Homer', \"email\":\"home@simpsons.com\",  \"phone\":\"555-222-1244\"  },\n            { 'name': 'Marge', \"email\":\"marge@simpsons.com\", \"phone\":\"555-222-1254\"  }\n        ]\n    });\n\n    Ext.create('Ext.grid.Grid', {\n        title: 'Simpsons',\n\n        store: store,\n\n        columns: [\n            { text: 'Name',  dataIndex: 'name', width: 200 },\n            { text: 'Email', dataIndex: 'email', width: 250 },\n            { text: 'Phone', dataIndex: 'phone', width: 120 }\n        ],\n\n        height: 200,\n        layout: 'fit',\n        fullscreen: true\n    });\n\nThe code above produces a simple grid with three columns. We specified a Store which will\nload JSON data inline. In most apps we would be placing the grid inside another container\nand wouldn't need to provide the {@link #cfg!height #height}, {@link #cfg!width #width} and\n{@link #cfg!fullscreen #cfg-fullscreen} options but they are included here to for demonstration.\n\nThe grid we created above will contain a header bar with a title ('Simpsons'), a row of\ncolumn headers directly underneath and finally the grid rows under the headers.\n\n## Columns\n\nBy default, each {@link Ext.grid.column.Column} is sortable and toggles between\nascending and descending sorting when you click on its header. There are several basic\nconfigs that can be applied to columns to change these behaviors. For example:\n\n    columns: [\n        {\n            text: 'Name',\n            dataIndex: 'name',\n            sortable: false,  // column cannot be sorted\n            width: 250\n        },\n        {\n            text: 'Email',\n            dataIndex: 'email',\n            hidden: true  // column is initially hidden\n        },\n        {\n            text: 'Phone',\n            dataIndex: 'phone',\n            width: 100\n        }\n    ]\n\nWe turned off sorting on the 'Name' column so clicking its header now has no effect. We\nalso made the Email column hidden by default (it can be shown again by using the\n{@link Ext.grid.plugin.ViewOptions} plugin). See the\n{@link Ext.grid.column.Column} for more details.\n\nA top-level column definition may contain a `{@link #cfg!columns columns}` configuration. This means that the\nresulting header will be a group header, and will contain the child columns.\n\n## Rows and Cells\n\nGrid extends the `{@link Ext.dataview.List}` component and connects records in the\nstore to `{@link Ext.grid.Row}` for the list's items. The Row component\nutilizes the configs of the grid's {@link Ext.grid.column.Column} to create the\nappropriate type of {@link Ext.grid.cell.Base}. Essentially, a Row is a container\nfor {@link Ext.Widget}.\n\nFor the most part, configuring a grid is about configuring the columns and their cells.\nThere are several built-in column types to display specific types of data:\n\n - {@link Ext.grid.column.Boolean} for true/false values.\n - {@link Ext.grid.column.Date} for date/time values.\n - {@link Ext.grid.column.Number} for numeric values.\n\nThese columns specify (via their {@link Ext.grid.column.Column#cfg!cell cell config}) one\nof these basic cell widget types:\n\n - {@link Ext.grid.cell.Boolean}\n - {@link Ext.grid.cell.Date}\n - {@link Ext.grid.cell.Number}\n\nIn addition to the above basic cell types, there are two other useful cell types to\nknow about:\n\n - {@link Ext.grid.cell.Text} is the base class for the boolean, date and number cell\n   classes. It is useful when a cell contains only text.\n - {@link Ext.grid.cell.Widget} is a cell class that manages a single child item (either\n   a {@link Ext.Component} or a {@link Ext.Widget}). The child item is\n   configured using the `{@link Ext.grid.cell.Widget#cfg!widget widget config}`. The most\n   important part of this config is the `{@link #cfg!xtype xtype}` of the child item to create.\n\n## Cells and Binding\n\nOne technique to controll cell content and styling is to use data binding to target\ncell configs like {@link Ext.grid.cell.Base#cfg!cls Ext.grid.cell.Base#cls} and {@link Ext.grid.cell.Base#cfg!bodyCls Ext.grid.cell.Base#bodyCls}.\nThis is done by assigning a {@link Ext.app.ViewModel} to each Row like so:\n\n     itemConfig: {\n         viewModel: true  // create default ViewModel for each item (i.e., Row)\n     }\n\nNow that each Row has a ViewModel, cells can bind to the fields of the associated record\nlike so:\n\n     columns: [{\n         ...\n         cell: {\n             bind: {\n                 cls: '{record.someCls}'\n             }\n         }\n     }]\n\nThe \"record\" property in the ViewModel is managed by the Row. As Row instances are\nrecycled due to buffered rendering, the associated record instance simply changes over\ntime.\n\n### Cell Widgets\n\nWhen using {@link Ext.grid.cell.Widget}, the contained widgets can also use binding to\nconfigure themsleves using properties of the associated record.\n\n     columns: [{\n         ...\n         cell: {\n             xtype: 'widgetcell',\n             widget: {\n                 xtype: 'button',\n                 bind: {\n                     text: 'Update {record.firstName}'\n                 }\n             }\n         }\n     }]\n\n### Row ViewModels\n\nIn some cases a custom ViewModel could be useful, for example to provide useful values\nvia {@link Ext.app.ViewModel#cfg!formulas formulas}.\n\n     itemConfig: {\n         viewModel: {\n             type: 'rowViewModel'\n         }\n     }\n\n## Renderers and Templates\n\nColumns provide two other mechanisms to format their cell content:\n\n - {@link Ext.grid.column.Column#cfg!renderer Ext.grid.column.Column#renderer}\n - {@link Ext.grid.column.Column#cfg!tpl Ext.grid.column.Column#tpl}\n\nThese column configs are processed by the {@link Ext.grid.column.Cell default cell type}\nfor a column. These configs have some downsides compared to data binding but are provided\nfor compatibility with previous releases.\n\n - Renderers and templates must update the cell content when _any_ field changes. They\n   cannot assume that only changes to the dataIndex will affect the rendering. Using\n   data binding, only the configs affected by the changed data will be updated.\n - Updates are processed synchronously in response to the record update notification.\n   Contrast to ViewModels which provide a buffered update mechanism.\n - Constructing HTML blocks in code (even in a template) is a common cause of security\n   problems such as XSS attacks.\n\n## Sorting & Filtering\n\nEvery grid is attached to a {@link Ext.data.Store}, which provides multi-sort and\nfiltering capabilities. It's easy to set up a grid to be sorted from the start:\n\n    var myGrid = Ext.create('Ext.grid.Panel', {\n        store: {\n            fields: ['name', 'email', 'phone'],\n            sorters: ['name', 'phone']\n        },\n        columns: [\n            { text: 'Name',  dataIndex: 'name' },\n            { text: 'Email', dataIndex: 'email' }\n        ]\n    });\n\nSorting at run time is easily accomplished by simply clicking each column header. If you\nneed to perform sorting on more than one field at run time it's easy to do so by adding\nnew sorters to the store:\n\n    myGrid.store.sort([\n        { property: 'name',  direction: 'ASC' },\n        { property: 'email', direction: 'DESC' }\n    ]);\n\nSee {@link Ext.data.Store} for examples of filtering.\n\n## Plugins\n\nGrid supports addition of extra functionality through plugins:\n\n- {@link Ext.grid.plugin.ViewOptions} - adds the ability to show/hide\n  columns and reorder them.\n\n- {@link Ext.grid.plugin.ColumnResizing} - allows for the ability to\n  resize columns.\n\n- {@link Ext.grid.plugin.Editable} - editing grid contents one row at a time.\n\n- {@link Ext.grid.plugin.RowOperations} - selecting and performing tasks\n  on severalrows at a time (e.g. deleting them).\n\n- {@link Ext.grid.plugin.PagingToolbar} - adds a toolbar at the bottom of\n  the grid that allows you to quickly navigate to another page of data.\n\n- {@link Ext.grid.plugin.Summary SummaryRow} - adds and pins an additional row to the\n  top of the grid that enables you to display summary data.\n"
}